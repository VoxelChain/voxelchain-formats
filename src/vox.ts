import {MATERIAL_INDEX_DIFFUSE, MATERIAL_INDEX_EMISSION, MATERIAL_INDEX_GLASS, MATERIAL_INDEX_METAL} from "./const";
import {getBufferMagic} from "./utils";

const CHUNK_HEADER_BYTE_LENGTH = (4 + (2 * Int32Array.BYTES_PER_ELEMENT));

const PALETTE_LENGTH = 256;

const DEFAULT_PALETTE = new Uint8Array([
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcc, 0xff, 0xff, 0xff, 0x99, 0xff, 0xff, 0xff, 0x66, 0xff, 0xff, 0xff, 0x33, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xcc, 0xff, 0xff, 0xff, 0xcc, 0xcc, 0xff,
  0xff, 0xcc, 0x99, 0xff, 0xff, 0xcc, 0x66, 0xff, 0xff, 0xcc, 0x33, 0xff, 0xff, 0xcc, 0x00, 0xff, 0xff, 0x99, 0xff, 0xff, 0xff, 0x99, 0xcc, 0xff, 0xff, 0x99, 0x99, 0xff, 0xff, 0x99, 0x66, 0xff,
  0xff, 0x99, 0x33, 0xff, 0xff, 0x99, 0x00, 0xff, 0xff, 0x66, 0xff, 0xff, 0xff, 0x66, 0xcc, 0xff, 0xff, 0x66, 0x99, 0xff, 0xff, 0x66, 0x66, 0xff, 0xff, 0x66, 0x33, 0xff, 0xff, 0x66, 0x00, 0xff,
  0xff, 0x33, 0xff, 0xff, 0xff, 0x33, 0xcc, 0xff, 0xff, 0x33, 0x99, 0xff, 0xff, 0x33, 0x66, 0xff, 0xff, 0x33, 0x33, 0xff, 0xff, 0x33, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xcc, 0xff,
  0xff, 0x00, 0x99, 0xff, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x33, 0xff, 0xff, 0x00, 0x00, 0xff, 0xcc, 0xff, 0xff, 0xff, 0xcc, 0xff, 0xcc, 0xff, 0xcc, 0xff, 0x99, 0xff, 0xcc, 0xff, 0x66, 0xff,
  0xcc, 0xff, 0x33, 0xff, 0xcc, 0xff, 0x00, 0xff, 0xcc, 0xcc, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0xff, 0xcc, 0xcc, 0x99, 0xff, 0xcc, 0xcc, 0x66, 0xff, 0xcc, 0xcc, 0x33, 0xff, 0xcc, 0xcc, 0x00, 0xff,
  0xcc, 0x99, 0xff, 0xff, 0xcc, 0x99, 0xcc, 0xff, 0xcc, 0x99, 0x99, 0xff, 0xcc, 0x99, 0x66, 0xff, 0xcc, 0x99, 0x33, 0xff, 0xcc, 0x99, 0x00, 0xff, 0xcc, 0x66, 0xff, 0xff, 0xcc, 0x66, 0xcc, 0xff,
  0xcc, 0x66, 0x99, 0xff, 0xcc, 0x66, 0x66, 0xff, 0xcc, 0x66, 0x33, 0xff, 0xcc, 0x66, 0x00, 0xff, 0xcc, 0x33, 0xff, 0xff, 0xcc, 0x33, 0xcc, 0xff, 0xcc, 0x33, 0x99, 0xff, 0xcc, 0x33, 0x66, 0xff,
  0xcc, 0x33, 0x33, 0xff, 0xcc, 0x33, 0x00, 0xff, 0xcc, 0x00, 0xff, 0xff, 0xcc, 0x00, 0xcc, 0xff, 0xcc, 0x00, 0x99, 0xff, 0xcc, 0x00, 0x66, 0xff, 0xcc, 0x00, 0x33, 0xff, 0xcc, 0x00, 0x00, 0xff,
  0x99, 0xff, 0xff, 0xff, 0x99, 0xff, 0xcc, 0xff, 0x99, 0xff, 0x99, 0xff, 0x99, 0xff, 0x66, 0xff, 0x99, 0xff, 0x33, 0xff, 0x99, 0xff, 0x00, 0xff, 0x99, 0xcc, 0xff, 0xff, 0x99, 0xcc, 0xcc, 0xff,
  0x99, 0xcc, 0x99, 0xff, 0x99, 0xcc, 0x66, 0xff, 0x99, 0xcc, 0x33, 0xff, 0x99, 0xcc, 0x00, 0xff, 0x99, 0x99, 0xff, 0xff, 0x99, 0x99, 0xcc, 0xff, 0x99, 0x99, 0x99, 0xff, 0x99, 0x99, 0x66, 0xff,
  0x99, 0x99, 0x33, 0xff, 0x99, 0x99, 0x00, 0xff, 0x99, 0x66, 0xff, 0xff, 0x99, 0x66, 0xcc, 0xff, 0x99, 0x66, 0x99, 0xff, 0x99, 0x66, 0x66, 0xff, 0x99, 0x66, 0x33, 0xff, 0x99, 0x66, 0x00, 0xff,
  0x99, 0x33, 0xff, 0xff, 0x99, 0x33, 0xcc, 0xff, 0x99, 0x33, 0x99, 0xff, 0x99, 0x33, 0x66, 0xff, 0x99, 0x33, 0x33, 0xff, 0x99, 0x33, 0x00, 0xff, 0x99, 0x00, 0xff, 0xff, 0x99, 0x00, 0xcc, 0xff,
  0x99, 0x00, 0x99, 0xff, 0x99, 0x00, 0x66, 0xff, 0x99, 0x00, 0x33, 0xff, 0x99, 0x00, 0x00, 0xff, 0x66, 0xff, 0xff, 0xff, 0x66, 0xff, 0xcc, 0xff, 0x66, 0xff, 0x99, 0xff, 0x66, 0xff, 0x66, 0xff,
  0x66, 0xff, 0x33, 0xff, 0x66, 0xff, 0x00, 0xff, 0x66, 0xcc, 0xff, 0xff, 0x66, 0xcc, 0xcc, 0xff, 0x66, 0xcc, 0x99, 0xff, 0x66, 0xcc, 0x66, 0xff, 0x66, 0xcc, 0x33, 0xff, 0x66, 0xcc, 0x00, 0xff,
  0x66, 0x99, 0xff, 0xff, 0x66, 0x99, 0xcc, 0xff, 0x66, 0x99, 0x99, 0xff, 0x66, 0x99, 0x66, 0xff, 0x66, 0x99, 0x33, 0xff, 0x66, 0x99, 0x00, 0xff, 0x66, 0x66, 0xff, 0xff, 0x66, 0x66, 0xcc, 0xff,
  0x66, 0x66, 0x99, 0xff, 0x66, 0x66, 0x66, 0xff, 0x66, 0x66, 0x33, 0xff, 0x66, 0x66, 0x00, 0xff, 0x66, 0x33, 0xff, 0xff, 0x66, 0x33, 0xcc, 0xff, 0x66, 0x33, 0x99, 0xff, 0x66, 0x33, 0x66, 0xff,
  0x66, 0x33, 0x33, 0xff, 0x66, 0x33, 0x00, 0xff, 0x66, 0x00, 0xff, 0xff, 0x66, 0x00, 0xcc, 0xff, 0x66, 0x00, 0x99, 0xff, 0x66, 0x00, 0x66, 0xff, 0x66, 0x00, 0x33, 0xff, 0x66, 0x00, 0x00, 0xff,
  0x33, 0xff, 0xff, 0xff, 0x33, 0xff, 0xcc, 0xff, 0x33, 0xff, 0x99, 0xff, 0x33, 0xff, 0x66, 0xff, 0x33, 0xff, 0x33, 0xff, 0x33, 0xff, 0x00, 0xff, 0x33, 0xcc, 0xff, 0xff, 0x33, 0xcc, 0xcc, 0xff,
  0x33, 0xcc, 0x99, 0xff, 0x33, 0xcc, 0x66, 0xff, 0x33, 0xcc, 0x33, 0xff, 0x33, 0xcc, 0x00, 0xff, 0x33, 0x99, 0xff, 0xff, 0x33, 0x99, 0xcc, 0xff, 0x33, 0x99, 0x99, 0xff, 0x33, 0x99, 0x66, 0xff,
  0x33, 0x99, 0x33, 0xff, 0x33, 0x99, 0x00, 0xff, 0x33, 0x66, 0xff, 0xff, 0x33, 0x66, 0xcc, 0xff, 0x33, 0x66, 0x99, 0xff, 0x33, 0x66, 0x66, 0xff, 0x33, 0x66, 0x33, 0xff, 0x33, 0x66, 0x00, 0xff,
  0x33, 0x33, 0xff, 0xff, 0x33, 0x33, 0xcc, 0xff, 0x33, 0x33, 0x99, 0xff, 0x33, 0x33, 0x66, 0xff, 0x33, 0x33, 0x33, 0xff, 0x33, 0x33, 0x00, 0xff, 0x33, 0x00, 0xff, 0xff, 0x33, 0x00, 0xcc, 0xff,
  0x33, 0x00, 0x99, 0xff, 0x33, 0x00, 0x66, 0xff, 0x33, 0x00, 0x33, 0xff, 0x33, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xcc, 0xff, 0x00, 0xff, 0x99, 0xff, 0x00, 0xff, 0x66, 0xff,
  0x00, 0xff, 0x33, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xcc, 0xff, 0xff, 0x00, 0xcc, 0xcc, 0xff, 0x00, 0xcc, 0x99, 0xff, 0x00, 0xcc, 0x66, 0xff, 0x00, 0xcc, 0x33, 0xff, 0x00, 0xcc, 0x00, 0xff,
  0x00, 0x99, 0xff, 0xff, 0x00, 0x99, 0xcc, 0xff, 0x00, 0x99, 0x99, 0xff, 0x00, 0x99, 0x66, 0xff, 0x00, 0x99, 0x33, 0xff, 0x00, 0x99, 0x00, 0xff, 0x00, 0x66, 0xff, 0xff, 0x00, 0x66, 0xcc, 0xff,
  0x00, 0x66, 0x99, 0xff, 0x00, 0x66, 0x66, 0xff, 0x00, 0x66, 0x33, 0xff, 0x00, 0x66, 0x00, 0xff, 0x00, 0x33, 0xff, 0xff, 0x00, 0x33, 0xcc, 0xff, 0x00, 0x33, 0x99, 0xff, 0x00, 0x33, 0x66, 0xff,
  0x00, 0x33, 0x33, 0xff, 0x00, 0x33, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xcc, 0xff, 0x00, 0x00, 0x99, 0xff, 0x00, 0x00, 0x66, 0xff, 0x00, 0x00, 0x33, 0xff, 0xee, 0x00, 0x00, 0xff,
  0xdd, 0x00, 0x00, 0xff, 0xbb, 0x00, 0x00, 0xff, 0xaa, 0x00, 0x00, 0xff, 0x88, 0x00, 0x00, 0xff, 0x77, 0x00, 0x00, 0xff, 0x55, 0x00, 0x00, 0xff, 0x44, 0x00, 0x00, 0xff, 0x22, 0x00, 0x00, 0xff,
  0x11, 0x00, 0x00, 0xff, 0x00, 0xee, 0x00, 0xff, 0x00, 0xdd, 0x00, 0xff, 0x00, 0xbb, 0x00, 0xff, 0x00, 0xaa, 0x00, 0xff, 0x00, 0x88, 0x00, 0xff, 0x00, 0x77, 0x00, 0xff, 0x00, 0x55, 0x00, 0xff,
  0x00, 0x44, 0x00, 0xff, 0x00, 0x22, 0x00, 0xff, 0x00, 0x11, 0x00, 0xff, 0x00, 0x00, 0xee, 0xff, 0x00, 0x00, 0xdd, 0xff, 0x00, 0x00, 0xbb, 0xff, 0x00, 0x00, 0xaa, 0xff, 0x00, 0x00, 0x88, 0xff,
  0x00, 0x00, 0x77, 0xff, 0x00, 0x00, 0x55, 0xff, 0x00, 0x00, 0x44, 0xff, 0x00, 0x00, 0x22, 0xff, 0x00, 0x00, 0x11, 0xff, 0xee, 0xee, 0xee, 0xff, 0xdd, 0xdd, 0xdd, 0xff, 0xbb, 0xbb, 0xbb, 0xff,
  0xaa, 0xaa, 0xaa, 0xff, 0x88, 0x88, 0x88, 0xff, 0x77, 0x77, 0x77, 0xff, 0x55, 0x55, 0x55, 0xff, 0x44, 0x44, 0x44, 0xff, 0x22, 0x22, 0x22, 0xff, 0x11, 0x11, 0x11, 0xff, 0x00, 0x00, 0x00, 0xff,
]);

// Default IMAP goes from 0-255
const DEFAULT_IMAP = new Uint8Array([...Array(PALETTE_LENGTH)].map((_, i) => i));
const IMAP_BUFFER = new Uint8Array(PALETTE_LENGTH);

const TEXT_DECODER_UTF8 = new TextDecoder("utf-8");

const CHUNK_ID_MAIN = "MAIN";
const CHUNK_ID_SIZE = "SIZE";
const CHUNK_ID_XYZI = "XYZI";
const CHUNK_ID_RGBA = "RGBA";
const CHUNK_ID_NTRN = "nTRN";
const CHUNK_ID_NGRP = "nGRP";
const CHUNK_ID_NSHP = "nSHP";
const CHUNK_ID_LAYR = "LAYR";
const CHUNK_ID_MATL = "MATL";
const CHUNK_ID_ROBJ = "rOBJ";
const CHUNK_ID_RCAM = "rCAM";
const CHUNK_ID_NOTE = "NOTE";
const CHUNK_ID_IMAP = "IMAP";

/**
 * The magic bytes of a vox file
 */
export const VOX_MAGIC = "VOX ";

/**
 * Indicates if the provided buffer is a vox file
 * @param buffer - The buffer to check
 */
export function isVOXFile(buffer: Uint8Array): boolean {
  return getBufferMagic(buffer) === VOX_MAGIC;
}

/**
 * Used for remapping material field names
 */
const MATERIAL_FIELD_NAME_REMAP: any = {
  "_type": "type",
  "_metal": "metalness",
  "_rough": "roughness",
  "_sp": "specular",
  "_ior": "ior",
  "_ldr": "ldr",
  "_emit": "emission",
  "_att": "attenuation",
  "_flux": "flux",
  "_trans": "transparency",
  "_alpha": "alpha",
  "_d": "density",
  "_media": "media",
};

/**
 * Represents a .vox file diffuse material
 */
export interface IVOXFileDiffuseMaterial {

}

/**
 * Represents a .vox file metal material
 */
export interface IVOXFileMetalMaterial {
  /**
   * The metalness of the metal material
   */
  metalness: number;
  /**
   * The roughness of the metal material
   */
  roughness: number;
  /**
   * The specular level of the metal material
   */
  specular: number;
}

/**
 * Represents a .vox file emissive material
 */
export interface IVOXFileEmissiveMaterial {
  /**
   * The flux of the emissive material
   */
  flux: number;
  /**
   * The emission of the emissive material
   */
  emission: number;
}

/**
 * Represents a .vox file glass material
 */
export interface IVOXFileGlassMaterial {
  /**
   * The refraction-index of the glass material
   */
  ior: number;
  /**
   * The roughness of the glass material
   */
  roughness: number;
  /**
   * The transparency of the glass material
   */
  transparency: number;
}

/**
 * Represents a .vox file material
 */
export interface IVOXFileMaterial {
  /**
   * The type of the material
   */
  type: string;
  /**
   * Diffuse material type
   */
  diffuse?: IVOXFileDiffuseMaterial;
  /**
   * Metal material type
   */
  metal?: IVOXFileMetalMaterial;
  /**
   * Emissive material type
   */
  emissive?: IVOXFileEmissiveMaterial;
  /**
   * Glass material type
   */
  glass?: IVOXFileGlassMaterial;
}

/**
 * The default options used when constructing a material
 */
const DEFAULT_OPTIONS_MATERIAL: Required<IVOXFileMaterial> = Object.freeze({
  type: null,
  diffuse: null,
  metal: null,
  emissive: null,
  glass: null,
});

/**
 * Represents a parsed .vox file
 */
export interface IVOXFile {
  data: Uint8Array;
  palette: Uint8Array;
  materials: IVOXFileMaterial[];
  width: number;
  height: number;
  depth: number;
}

/**
 * Parse the provided vox file
 * @param buffer - The vox file data
 */
export function parseVOXFile(buffer: Uint8Array): IVOXFile {
  let byteOffset = 0x0;
  const reader = new DataView(buffer.buffer);
  // ## Magic ##
  if (!isVOXFile(buffer)) {
    throw new Error(`Invalid magic, expected '${VOX_MAGIC}' but got '${getBufferMagic(buffer)}'`);
  }
  byteOffset += 0x4;
  // ## Version ##
  const version = reader.getUint32(byteOffset, true); byteOffset += Int32Array.BYTES_PER_ELEMENT;
  // ## Chunks ##
  let sizeX = -1;
  let sizeY = -1;
  let sizeZ = -1;
  let palette = DEFAULT_PALETTE;
  let imap = DEFAULT_IMAP;
  let data: Uint8Array = null;
  const materials: IVOXFileMaterial[] = [...Array(PALETTE_LENGTH)].map(_ => null);
  // Read chunks until EOF
  while (byteOffset < buffer.byteLength) {
    let chunkByteOffset = byteOffset;
    const chunkId = getBufferMagic(buffer, chunkByteOffset); chunkByteOffset += 0x4;
    const chunkContentLength = reader.getUint32(chunkByteOffset, true); chunkByteOffset += Int32Array.BYTES_PER_ELEMENT;
    const chunkChildrenLength = reader.getUint32(chunkByteOffset, true); chunkByteOffset += Int32Array.BYTES_PER_ELEMENT;
    switch (chunkId) {
      case CHUNK_ID_MAIN: {

      } break;
      case CHUNK_ID_SIZE: {
        sizeX = reader.getUint32(chunkByteOffset, true); chunkByteOffset += Int32Array.BYTES_PER_ELEMENT;
        sizeY = reader.getUint32(chunkByteOffset, true); chunkByteOffset += Int32Array.BYTES_PER_ELEMENT;
        sizeZ = reader.getUint32(chunkByteOffset, true); chunkByteOffset += Int32Array.BYTES_PER_ELEMENT;
        data = new Uint8Array(sizeX * sizeY * sizeZ * 1);
      } break;
      case CHUNK_ID_XYZI: {
        if (sizeX === -1 || sizeX === -1 || sizeX === -1) {
          throw new ReferenceError(`'SIZE' chunk is expected before 'XYZI' chunk`);
        }
        const voxelCount = reader.getUint32(chunkByteOffset, true); chunkByteOffset += Int32Array.BYTES_PER_ELEMENT;
        // Fill voxel data
        for (let ii = 0; ii < voxelCount; ++ii) {
          const voxelX = reader.getUint8(chunkByteOffset); chunkByteOffset += Uint8Array.BYTES_PER_ELEMENT;
          const voxelY = reader.getUint8(chunkByteOffset); chunkByteOffset += Uint8Array.BYTES_PER_ELEMENT;
          const voxelZ = reader.getUint8(chunkByteOffset); chunkByteOffset += Uint8Array.BYTES_PER_ELEMENT;
          const color  = reader.getUint8(chunkByteOffset); chunkByteOffset += Uint8Array.BYTES_PER_ELEMENT;
          const dstIndex = (voxelX * sizeX * sizeY) + (voxelZ * sizeX) + (voxelY);
          data[(dstIndex * 1) + 0] = color;
        }
      } break;
      case CHUNK_ID_RGBA: {
        palette = new Uint8Array(PALETTE_LENGTH * 4);
        for (let ii = 1; ii < PALETTE_LENGTH; ++ii) {
          palette[(ii * 4) + 0] = reader.getUint8(chunkByteOffset); chunkByteOffset += Uint8Array.BYTES_PER_ELEMENT;
          palette[(ii * 4) + 1] = reader.getUint8(chunkByteOffset); chunkByteOffset += Uint8Array.BYTES_PER_ELEMENT;
          palette[(ii * 4) + 2] = reader.getUint8(chunkByteOffset); chunkByteOffset += Uint8Array.BYTES_PER_ELEMENT;
          palette[(ii * 4) + 3] = reader.getUint8(chunkByteOffset); chunkByteOffset += Uint8Array.BYTES_PER_ELEMENT;
        }
      } break;
      case CHUNK_ID_NTRN: {

      } break;
      case CHUNK_ID_NGRP: {

      } break;
      case CHUNK_ID_NSHP: {

      } break;
      case CHUNK_ID_LAYR: {

      } break;
      case CHUNK_ID_MATL: {
        const materialId = reader.getUint32(chunkByteOffset, true); chunkByteOffset += Int32Array.BYTES_PER_ELEMENT;
        const keyLength = reader.getUint32(chunkByteOffset, true); chunkByteOffset += Int32Array.BYTES_PER_ELEMENT;
        // Read dict
        const material: any = {};
        // Default to diffuse
        material.type = "diffuse";
        for (let ii = 0; ii < keyLength; ++ii) {
          // Read key
          const keyLength = reader.getUint32(chunkByteOffset, true); chunkByteOffset += Int32Array.BYTES_PER_ELEMENT;
          const key = TEXT_DECODER_UTF8.decode(buffer.subarray(chunkByteOffset, chunkByteOffset + keyLength));
          chunkByteOffset += keyLength * Uint8Array.BYTES_PER_ELEMENT;
          // Read value
          const valueLength = reader.getUint32(chunkByteOffset, true); chunkByteOffset += Int32Array.BYTES_PER_ELEMENT;
          const value = TEXT_DECODER_UTF8.decode(buffer.subarray(chunkByteOffset, chunkByteOffset + valueLength));
          chunkByteOffset += valueLength * Uint8Array.BYTES_PER_ELEMENT;
          // Handle material type
          if (key === `_type`) {
            switch (value) {
              case "_diffuse": {material.type = "diffuse";} break;
              case "_metal": {material.type = "metal";} break;
              case "_emit": {material.type = "emissive";} break;
              case "_glass": {material.type = "glass";} break;
              default: {throw new Error(`Unexpected material type '${value}'`);} break;
            }
          }
          // Handle material property
          else {
            // Make sure we can remap the material field key
            if (!MATERIAL_FIELD_NAME_REMAP.hasOwnProperty(key)) {
              throw new ReferenceError(`Unexpected MATL field '${key}'`);
            }
            const normalizedKey = MATERIAL_FIELD_NAME_REMAP[key];
            material[normalizedKey] = parseFloat(value);
          }
        }
        // Normalize parsed material
        const normalizedMaterial: IVOXFileMaterial = Object.assign({}, DEFAULT_OPTIONS_MATERIAL, {});
        normalizedMaterial.type = material.type;
        switch (material.type) {
          case "diffuse": {
            normalizedMaterial.diffuse = {};
          } break;
          case "metal": {
            normalizedMaterial.metal = {
              metalness: (material.metalness ? material.metalness : 0),
              roughness: (material.roughness ? material.roughness : 0),
              specular: (material.specular ? material.specular : 1),
            };
          } break;
          case "emissive": {
            normalizedMaterial.emissive = {
              flux: 1 + (material.flux ? material.flux : 0),
              emission: (material.emission ? material.emission : 0),
            };
          } break;
          case "glass": {
            normalizedMaterial.glass = {
              ior: (material.ior ? material.ior : 0),
              roughness: (material.roughness ? material.roughness : 0),
              transparency: (material.transparency ? material.transparency : 0),
            };
          } break;
          default: {
            throw new Error(`Unexpected material type '${material.type}'`);
          } break;
        }
        // Save material
        materials[materialId - 1] = normalizedMaterial;
      } break;
      case CHUNK_ID_ROBJ: {

      } break;
      case CHUNK_ID_RCAM: {

      } break;
      case CHUNK_ID_NOTE: {

      } break;
      case CHUNK_ID_IMAP: {
        imap = IMAP_BUFFER;
        for (let ii = 0; ii < PALETTE_LENGTH; ++ii) {
          imap[ii] = reader.getUint8(chunkByteOffset); chunkByteOffset += Uint8Array.BYTES_PER_ELEMENT;
        }
        throw new Error(`'IMAP' chunk present, but unsupported at the moment`);
      } break;
      default: {
        throw new Error(`Unexpected chunk id '${chunkId}'`);
      }
    }
    // Skip to next chunk by skipping the chunk's content bytelength (including the header)
    const chunkByteLength = chunkContentLength + CHUNK_HEADER_BYTE_LENGTH;
    byteOffset += chunkByteLength;
  }
  return {
    data: data,
    palette: palette,
    width: sizeX,
    height: sizeY,
    depth: sizeZ,
    materials: materials,
  };
}

/**
 * Compiles an unsigned 8-bit 4-item buffer based on the provided materials
 * @param materials - The materials to compile into a buffer
 */
export function compileVOXMaterialBuffer(materials: IVOXFileMaterial[]): Uint8Array {
  const buffer = new Uint8Array(materials.length * 4);
  for (let ii = 0; ii < materials.length; ++ii) {
    const index4 = ii * 4;
    const m = materials[ii];
    switch (m.type) {
      case "diffuse": {
        buffer[index4 + 0] = MATERIAL_INDEX_DIFFUSE;
        buffer[index4 + 1] = 0;
        buffer[index4 + 2] = 0;
        buffer[index4 + 3] = 0;
      } break;
      case "metal": {
        buffer[index4 + 0] = MATERIAL_INDEX_METAL;
        buffer[index4 + 1] = Math.floor(m.metal.metalness * 255);
        buffer[index4 + 2] = Math.floor(m.metal.roughness * 255);
        buffer[index4 + 3] = Math.floor((m.metal.specular - 1) * 255);
      } break;
      case "emissive": {
        buffer[index4 + 0] = MATERIAL_INDEX_EMISSION;
        buffer[index4 + 1] = Math.floor(m.emissive.emission * 255);
        buffer[index4 + 2] = Math.floor((m.emissive.flux / 5) * 255);
        buffer[index4 + 3] = 0;
      } break;
      case "glass": {
        buffer[index4 + 0] = MATERIAL_INDEX_GLASS;
        buffer[index4 + 1] = Math.floor((m.glass.ior / 2) * 255);
        buffer[index4 + 2] = Math.floor(m.glass.roughness * 255);
        buffer[index4 + 3] = Math.floor(m.glass.transparency * 255);
      } break;
      default: {
        throw new Error(`Unexpected material type '${m.type}'`);
      } break;
    }
  }
  return buffer;
}
